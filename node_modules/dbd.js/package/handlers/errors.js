const Discord = require("discord.js")
const interpreter = require("../interpreter.js")

const errorHandler = async (d, errorMessage, returnMsg = false) => {

    const embed = new Discord.MessageEmbed()

    let send = true

    let reactions = []
    
    if (errorMessage.includes("{execute:")) {
        const command = errorMessage.split("{execute:")[1].split("}")[0]
        errorMessage = errorMessage.replace(`{execute:${command}}`, "")
        const cmd = d.client.awaited_commands.find(c => c.name === command)
        if (!cmd) return d.error(`:x: Invalid awaited command '${command}' in {execute:${command}}`)
        await d.interpreter(d.client, d.message, d.args, cmd)
    }
  
    if (errorMessage.includes("{title:")) {
        const inside = errorMessage.split("{title:")[1].split("}")[0]
        embed.setTitle(inside.addBrackets())
        errorMessage = errorMessage.replace(`{title:${inside}}`, "")
    }
    
    if (errorMessage.includes("{url:")) {
        const url = errorMessage.split("{url:")[1].split("}")[0]
        
        if (embed.title) embed.setURL(url.addBrackets())
        
        errorMessage =  errorMessage.replace(`{url:${url}}`, "") 
    }
    
    if (errorMessage.includes("{timestamp")) {
        const rest = errorMessage.includes("{timestamp:") ? errorMessage.split("{timestamp:")[1].split("}")[0] : "" 
        
      	embed.setTimestamp(Number(rest) || Date.now()) 
      	
        errorMessage = errorMessage.replace(`{timestamp${rest ? ":" + rest : ""}}`, "") 
    }
  
    if (errorMessage.includes("{author:")) {
        const inside = errorMessage.split("{author:")[1].split("}")[0].split(":")
        let to = inside.join(":")
        const text = inside.shift()
        const url = inside.join(":")
        embed.setAuthor(text.addBrackets(), typeof url === "string" ? url.addBrackets() : undefined)
        errorMessage = errorMessage.replace(`{author:${to}}`, "")
    }

    if (errorMessage.includes("{footer:")) {
        const inside = errorMessage.split("{footer:")[1].split("}")[0].split(":")
        let to = inside.join(":")
        const text = inside.shift()
        const url = inside.join(":")
        embed.setFooter(text.addBrackets(), typeof url === "string" ? url.addBrackets() : undefined)
        errorMessage = errorMessage.replace(`{footer:${to}}`, "")
    }

    if (errorMessage.includes("{description:")) {
        const inside = errorMessage.split("{description:")[1].split("}")[0]
        embed.setDescription(inside.addBrackets())
        errorMessage = errorMessage.replace(`{description:${inside}}`, "")
    }

    if (errorMessage.includes("{color:")) {
        const inside = errorMessage.split("{color:")[1].split("}")[0]
        embed.setColor(inside.addBrackets())
        errorMessage = errorMessage.replace(`{color:${inside}}`, "")
    }

    if (errorMessage.includes("{thumbnail:")) {
        const inside = errorMessage.split("{thumbnail:")[1].split("}")[0]
        embed.setThumbnail(inside.addBrackets())
        errorMessage = errorMessage.replace(`{thumbnail:${inside}}`, "")
    }

    if (errorMessage.includes("{field:")) {
        const fields = errorMessage.split("{field:")
        fields.shift()
        for (const after of fields) {
            const inside = after.split("}")[0].split(":") 
            let inline = false 
            let arg
            if (inside.length > 2 && ["yes", "no"].some(w => inside[inside.length - 1] === w)) {
                arg = inside.pop() 
                inline = arg === "yes" 
            }
            embed.addField(inside[0].addBrackets(), inside.slice(1).join(":").addBrackets(), inline)
            errorMessage = errorMessage.replace(`{field:${inside.join(":")}${arg ? `:${arg}` : ""}}`, "")
        }
    }

    if (errorMessage.includes("{image:")) {
        const inside = errorMessage.split("{image:")[1].split("}")[0]
        embed.setImage(inside.addBrackets())
        errorMessage = errorMessage.replace(`{image:${inside}}`, "")
    }

    if (errorMessage.includes("{reactions:")) {
        const inside = errorMessage.split("{reactions:")[1].split("}")[0]
        for (const reaction of inside.split(" ").join("").split(",")) {
          reactions.push(reaction) 
        } 
        errorMessage = errorMessage.replace(`{reactions:${inside}}`, "") 
    }
  
    if (!embed.length && !embed.thumbnail && !embed.image) send = false

    if (returnMsg === true) {
        return {
            reactions: reactions.length ? reactions : undefined, 
            embed: send ? embed : undefined,
            message: errorMessage.addBrackets()
        }
    }

    const m = await d.message.channel.send(errorMessage.addBrackets(), send ? embed : undefined).catch(Err => {
    })

    if (!m) return
 
    if (m && reactions.length) {
      for (const reaction of reactions) {
        await m.react(reaction).catch(err => {}) 
      } 
    }
  
    if (returnMsg === "id") {
        return m.id
    } else if (returnMsg === "object") {
        return m
    }
}

module.exports = errorHandler