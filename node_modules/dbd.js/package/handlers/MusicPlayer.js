const embed = require("./errors.js")
const ytdl = require("ytdl-core")
const sdl = require("soundcloud-downloader").default
require('ffmpeg-static')
require(`@discordjs/opus`)
let timeout
const execute = async (d, old, error) => {
    
    const server = d.client.servers.get(d.message.guild.id)
    d.message.guild.me.voice.setSelfDeaf(server.deafen)
    async function Stream(song) {
    if(song.stream === "ytdl") {
        return ytdl(song.url(), {
            quality:"highestaudio",
            requestOptions: {
                headers: {
                    cookie:d.client.cookie
                }
            }
        })
    } else if(song.stream === "sdl"){
        return await sdl.download(song.url(), song.clientIdd || null)
    }
}
 
    
    const play = server.connection
    const dispatcher = await server.connection.play(await Stream(server.songs[0]))
    //Queue system start
    .on('start', () => {

        server.state = "PLAYING"
        d.client.emit("musicStart", server, "shot_lol_die_minecrft_awdjsbdaidsdiaxsdowharhapsndoawodh9q")
        
      clearTimeout(timeout)
    })
    .on('finish', async () => {
        server.state = "FINISH"
        
        if(server.pruneEnabled) server.songs[0].message.delete()
        if(server.loopQueue === false) {
            server.songs.shift()
        } else if(server.loopQueue === true) {

            if(!server.songs.length < 1 && server.songs.length > 1) {
                var songs = server.songs[0]

                server.songs.push(songs)
                server.songs.shift() //do not touch 
            }
        }
        
        function timedend() {
            
        timeout = setTimeout(async () => {
          server.text.send(`Queue ended, left voice channel.`)

          await server.voice.leave()
          d.client.emit("musicDestroyed", server, "this param is no need, why do i even fill this")

          return d.client.servers.delete(d.message.guild.id)
        }, server.vc_legacy);
    } 
    if(!server.songs.length) {

        server.state = "ENDED"
        d.client.emit("musicFinished", server, "tensura season 2 owo, definitely not sponsored") // Event emitted when Music Ends

        timedend()

    } else {
    
                d.client.servers.set(d.message.guild.id, server)
                await execute(d, true, error)
    }
    })
    .on('error', async err => {

        if(!err) return;

        clearTimeout(timeout)

        console.log(err.message)
        embed(d, error)

        d.client.emit("musicError", server, error)
        await server.voice.leave()

        return d.client.servers.delete(d.message.guild.id)
    })

    dispatcher.setVolume(server.volume / 100)

}
module.exports = execute