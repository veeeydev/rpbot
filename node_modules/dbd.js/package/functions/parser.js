const Parser = {
  $setServerVar: "Sets a server variable value;$setServerVar[variable;value;guildID (optional)]",
  $serverCount: "Displays the amount of servers your bot's in.",
  $ram: "returns the memory usage in MB.",
  $activity: "Return's the user activities.;$activity or $activity[userID]",
  $findChannel: "Finds a channel in this server.;$findChannel[ID/mention/name]",
  $ping: "Returns the Bot websocket ping",
  $findUser: "Returns an user's ID, or the author's ID;$findUser[ID/name/name#discriminator/mention]",
  $globalCooldown: "Sets a Global Cooldown to this user;$globalCooldown[time;error message]",
  $getUserBadges: "Returns the user's badges\nNitro Classic and Nitro Boosting badges are not 100% guaranteed to be retrieved.;$getUserBadges or $getUserBadges[userID]",
  $ban: "Bans an user from the server by using their ID.;$ban[userID;reason;messages to delete (days)]",
  $disableMentions: "Replaces all the user mentions with their user names",
  $authorID: "Returns the author's ID.",
  $serverBoostCount: "Returns the amount of boosts this server has",
  $cooldown: "Sets a server user cooldown;$cooldown[time;error message]",
  $eval: "Evals a code;$eval[code (dbd.js);returnCode (optional) (yes/no)]",
  $truncate: "Truncates the number to 0 decimals.;$truncate[number]",
  $memberExists: "Checks if given user ID is in the server;$memberExists[userID]",
  $parseDate: "Parses given ms to date or time;$parseDate[ms;date/time]",
  $customEmoji: "Returns a custom emoji;$customEmoji[name]",
  $createChannel: "Creates a channel with given type and name. If 3rd field is set to 'yes', the function will return the newly created channel ID. If categoryID field is present, the channel will be created under the category with given ID;$createChannel[name;type;return ID (yes/no);categoryID (optional)]",
  $deleteChannels: "Delete a channel or channels by using their IDs.;$deleteChannels[channelID;channelID;...]",
  $dateStamp: "Returns the current date since 1970 in ms.",
  $thumbnail: "Sets a thumbnail to the embed;$thumbnail[url]",
  $systemChannelID: "Returns the system channel ID of this server (if any);$systemChannelID or $systemChannelID[guildID]",
  $serverVerificationLevel: "Returns the server verification level of this guild",
  //$mention: "Returns the mention of the author",
  $round: "Rounds the number to the unit;$round[number]",
  $platform: "Returns the devices the user is using for Discord;$platform or $platform[userID]",
  $reactionCollector: "Creates a reaction collector for given message ID;$reactionCollector[messageID;userFilter;time;reaction1,reaction2,...;command1,command2,...;removeReactions (yes/no)]",
  $roleName: "Returns a Role name using their ID;$roleName[roleID]",
  $roleCount: "Returns the amount of roles in this guild",
  $channelCount: "Returns the amount of channels in this guild;$channelCount or $channelCount[type]",
  $awaitReaction: "Awaits an user reaction in this message;$awaitReaction[userFilter;time;bot message;reaction1,reaction2,...;command1,command2,...;error message]",
  $channelSendMessage: "Sends a message to given channel ID\nIf last field is set to yes, it'll return the newly sent message ID;$channelSendMessage[channelID;message;return message ID (yes/no) (optional)]",
  $kick: "Kicks an user from the server by using their ID;$kick[userID;reason (optional)]",
  $serverCooldown: "Sets a Server cooldown;$serverCooldown[time;error message]",
  $hasPerms: "Check if given user ID has the provided perms;$hasPerms[userID;perm1;perm2;...]",//?
  $mentionedRoles: "Returns the roles that were mentioned by the user;$mentionedRoles[mention number]",
  $joinSplitText: "Joins the $textSplit indexes by <separator>;$joinSplitText[separator]||$joinSplitText[ | ] //will return 'hello | bye | lol'\n\n$textSplit[hello-bye-lol;-]",
  $globalUserLeaderboard: "Creates a global user leaderboard;$globalUserLeaderboard[variable;asc/desc (optional);{top}.- {username} - {value};list (optional);page (optional)]",
  $getGlobalUserVar: "Gets a global user variable value;$getGlobalUserVar[variable;userID (optional)]",
  $setGlobalUserVar: "Sets a global user variable value;$setGlobalUserVar[variable;value;userID (optional)]",
  $isNumber: "Checks if given input is a number or not;$isNumber[value]",
  $textSplit: "Splits a text by <separator>;$textSplit[some_text;separator]",
  $serverIcon: "Returns the Server Icon;$serverIcon or $serverIcon[guildID;size (optional);dynamic (yes/no)(optional)]",
  $giveRoles: "Gives a role or roles to given user ID;$giveRoles[userID;roleID;roleID;...]",
  $findMember: "Finds a member in this guild, returns the user ID, or author ID;$findMember[nickname/ID/mention/username/username#dicriminator]",
  $addEmoji: "Adds an emoji to this guild. If role IDs are given, the emoji will only be usable by users with one of provided role IDs;$addEmoji[url;name;returnEmoji (yes/no)(optional);roleID1;roleID2;...]",
  $splitText: "Gets a value from $textSplit;$splitText[index]",
  $botCount: "Returns the amount of bots in this server",
  $textSplitMap: "Creates a loop over all the indexes of $textSplit, $message[1] will contain said value;$textSplitMap[awaited command 1;awaited command 2;...]",
  $onlyForIDs: "Only given user IDs will be able to execute this command;$onlyForIDs[userID;userID;...;error message]",
  $noEscapingMessage: "Special characters won't be replaced;$noEscapingMessage or $noEscapingMessage[arg number]",
  $message: "Returns the user's \nIf this function is called on a slash command, it will contain the value of either given option index or all the option values;$message or $message[arg number]",
  $channelNSFW: "Returns whether the channel is nsfw or not;$channelNSFW or $channelNSFW[channelID]",
  $takeRoles: "Takes a role or roles from given user ID;$takeRoles[userID;roleID;roleID;...]",
  $membersCount: "Returns the amount of users in this server;$membersCount or $membersCount[guildID;presence (optional);countBots (optional)(yes/no)]",
  $channelName: "Returns the Channel Name;$channelName or $channelName[channelID]",
  $userID: "Returns an user ID with given user name;$userID[username]",
  $addTimestamp: "Sets a timestamp to the embed;$addTimestamp or $addTimestamp[ms]",
  $username: "Returns the user's username;$username of $username[userID]",
  "$clear[": "Clears an amount of messages from given channel ID;$clear[amount;filter (optional);channelID (optional)]",
  $sendMessage: "Sends a message to this channel;$sendMessage[message;return message ID (yes/no)(optional)]",
  $description: "Sets an embed description;$description[text]",
  $userAvatar: "Returns the user's avatar;$userAvatar or $userAvatar[userID;size (optional);dynamic (optional)]",
  $image: "Sets an image to the embed;$image[url]",
  $guildRoles: "Returns all the roles of this guild;$guildRoles or $guildRoles[id/name/mention]",
  $title: "Sets an embed title;$title[text;url (optional)]",
  $sum: "Sum up the given args;$sum[1;3;...]",
  "$loop[": "loops an awaited command name for  times;$loop[times;awaited command 1;awaited command 2;...]",
  $editMessage: "Edits a message with given message ID;$editMessage[messageID;new message;channelID (optional)]",
  $banCount: "Returns the amount of users banned",
  $wait: "Stops the code execution for given time;$wait[time]",
  $roleID: "returns the role ID of given role name;$roleID[role name]",
  $commandName: "Returns the command name",
  $commandCode: "Returns the command code",
  $sub: "Subtracts a number;$sub[1;2;...]",
  $numberSeparator: "Separates a number in thousands;$numberSeparator[number;separator (optional)]",
  $hasRoles: "Checks if given user ID has the provided roles;$hasRoles[userID;roleID;roleID;...]",
  $channelType: "Returns the channel type;$channelType or $channelType[channelID]",
  $allMembersCount: "Returns the total user count of the bot",
  $serverContentFilter: "Returns the content filter level of this guild",
  $roleExists: "Checks if given role ID exists;$roleExists[roleID]",
  $channelExists: "Checks if given channel ID exists;$channelExists[channelID]",
  "$random[": "Returns a random number from X to Y;$random[min;max;allowDecimals (yes/no)]",
  $userExists: "Checks if the given user ID exists;$userExists[userID]",
  $multi: "Multiplicates X by Y;$multi[1;4;...]",
  $unban: "Unbans a user from the server by using their ID or username;$unban[userID/username;reason (optional)]",
  $randomText: "Returns a random text from given texts;$randomText[some;random;text;...]",
  $userLeaderboard: "Creates an user leaderboard;$userLeaderboard[variable;asc/desc (optional);{top}.- {username} - {value};list (optional);page (optional)]",
  $noMentionMessage: "User's message without mentions;$noMentionMessage or $noMentionMessage[arg number]",
  $replaceText: "Replaces A to X in TEXT;$replaceText[some text;sample;new]",
  $divide: "Divides a number by X;$divide[5;2]",
  $getUserVar: "Gets an user variable value;$getUserVar[variable;userID (optional)]",
  "$color[": "Sets a embed color;$color[hex or number]",
  $guildID: "Returns the ID of this guild or given guild name.;$guildID[guild name]",
  $addField: "Adds a field to the embed;$addField[name;value;inline (yes/no)(optional)]",
  $changeNickname: "Changes the nickname of given user ID;$changeNickname[userID;nickname]",
  $setUserVar: "Sets a user variable value;$setUserVar[variable;value;userID (optional)]",
  $addCmdReactions: "Adds reactions to the user's message;$addCmdReactions[ðŸ˜€;ðŸ˜Ž]",
  $discriminator: "Returns the user's discriminator;$discriminator or $discriminator[userID]",
  $awaitMessages: "Awaits a message from given user ID or everyone in this channel.;$awaitMessages[userID/everyone;time;reply1,reply2,.../everything;command1,command2,...;error message]",
  $getServerVar: "Gets a server variable value;$getServerVar[variable;guildID (optional)]",
  "$mentioned[": "Returns the ID of the mentioned user;$mentioned[mention number;return author ID (yes/no)(optional)]",
  $addReactions: "adds reactions to the bot's response;$addReactions[ðŸ˜€;ðŸ˜Ž]",
  $nickname: "returns the nickname of the user in this guild (if any);$nickname or $nickname[userID]",
  $footer: "sets an embed footer;$footer[text;url]",
  $editIn: "edits the bot's message after given time;$editIn[time;new message;next message;...]",
  $dm: "dms the author;$dm or $dm[userID]",
  $useChannel: "command will be sent to given channel ID;$useChannel[channelID]",
  $isBoosting: "checks if the user is boosting this server;$isBoosting or $isBoosting[userID]",
  $mentionedChannels: "returns the mentioned channel ID;$mentionedChannels[mention number;return current channel ID (yes/no)(optional)]",
  $author: "sets an embed author;$author[text;url]",
  $toLocaleUppercase: "capitalizes the first letter of all the given words;$toLocaleUpperCase[some words here]",
  "$onlyIf[": "checks if a condition is true;$onlyIf[value(!=/==/>=/<=/>/<)value2;error message]",
  $toUppercase: "makes all the letters uppercase;$toUpperCase[text]",
  $toLowercase: "makes all the letters lowercase;$toLowerCase[text]",
  $channelID: "returns the channel ID of this channel;$channelID or $channelID[channel name]",
  $commandsCount: "returns the amount of commands of this bot",
  $userTag: "returns the user name and discriminator;$userTag or $userTag[userID]",
  $jsonRequest: "makes a json request (GET method) and returns a property from it;$jsonRequest[url;property;error message;headerName:headerValue;headerName:headerValue;...]",
  $ownerID: "returns the server owner id;$ownerID or $ownerID[guildID]",
  $serverFeatures: "returns the guild's features;$serverFeatures or $serverFeatures[guildID]",
  $highestRole: "returns the user's highest role in this guild;$highestRole or $highestRole[userID]",
  $randomString: "generates a random string;$randomString[length]",
  $getServerInvite: "creats an invite link to this server;$getServerInvite or $getServerInvite[guildID]",
  $getChannelVar: "gets a channel variable value;$getChannelVar[variable;channelID (optional)]",
  $setChannelVar: "sets a channel variable value;$setChannelVar[variable;value;messageID (optional)]",
  $checkContains: "checks if given text provides any of the texts;$checkContains[message;word1;word2;...]",
  $deleteRoles: "deletes a role or roles;$deleteRoles[roleID;roleID;...]",
  $shardID: "Returns The Shard ID.",
  //$reactionRoleRemove: "removes a reaction role",
  $voiceID: "returns the voice channel's ID this user is connected to. (if any);$voiceID or $voiceID[userID]",
  $partial: "checks if the object structure is partial or not",
  $rolePosition: "returns the role position of this role;$rolePosition[roleID]",
  $deletecommand: "deletes the user's message",
  $attachment: "adds an attachment.\nIf name field is given, you must specify the extension for the attachment (png, webp, or gif);$attachment[url;name (optional)]",
  $queueLength: "Returns the amount of songs in the queue (or 0)",
  $isValidInvite: "checks if an invite url is valid;$isValidInvite[invite code]",
  $setVar: "sets a global var;$setVar[variable;value]",
  $isBot: "Returns if the user is a bot or not.;$isBot or $isBot[userID]",
  $getVar: "gets a global var;$getVar[variable]",
  $emojiName: "Returns the emoji name the user reacted with",
  $getTextSplitLength: "gets the length of the $textSplit",
  $createRole: "creates a role in this guild;$createRole[name;color (optional);mentionable (optional);hoisted (optional);position (optional);permission;permission;...]",
  $serverName: "Returns the Current Guild or ID of Guild;$serverName or $serverName[guildID]",
  //$reactionRoleAdd: "adds a reaction role",
  $onlyPerms: "checks if the author has the provided permissions.;$onlyPerms[perm1;perm2;...;error message]",
  $checkCondition: "Checks if given condition is true or false.;$checkCondition[value(!=/==/>=/<=/>/<)value2]",
  $serverIDs: "returns the ID of all the servers this bot is in;$serverIDs or $serverIDs[separator]",
  $clientID: "Returns the Bot ID",
  $blackListRoleIDs: "Blacklist roles from using this command by using their IDs.;$blackListRoleIDs[roleID;roleID;...;error message]",
  $blackListIDs: "Blacklist users from using this command by using their IDs.;$blackListIDs[userID;userID;...;error message]",
  $emojiID: "Returns the emoji ID of the emoji the user reacted with",
  $editTextSplitElement: "Edits the value from given index.;$editTextSplitElement[index;new value]",
  $blackListServerIDs: "Blacklist servers from using this command;$blackListServerIDs[guildID;guildID;...;error message]",
  $authorMessage: "Returns the ID of the user this message belongs to. (for callbacks like reaction add / remove, or message delete/ update)",
  $removeTextSplitElement: "Removes an element from $textSplit by using its index.;$removeTextSplitElement[index]",
  $findTextSplitIndex: "Finds the index of a splitted value in $textSplit;$findTextSplitIndex[value]",
  //$userMessageID: "Returns the user's message ID",
  $emojiToString: "Returns the emoji the user reacted with",
  $queue: "Returns a queue of songs;$queue or $queue[page;amount;{number}) {title} by <@{userID}>]",
  $authorAvatar: "Returns the author's avatar.",
  $creationDate: "Returns the creation date of given channel, guild, emoji, user or role ID.;$creationDate[emojiID/userID/roleID/channelID/guildID;date/time/ms (optional)]",
  $userRoles: "Returns the user roles.;$userRoles or $userRoles[userID;ids/mentions/names (optional);separator (optional)]",
  $status: "Returns the user's presence status. (Presence intent needs to be enabled on Discord Dev Portal);$status or $status[userID]",
  $charCount: "Counts character of a text, or the user's message.;$charCount or $charCount[text]",
  $getMessageVar: "Gets a message variable value;$getMessageVar[variable;messageID (optional)]",
  $memberJoinedDate: "Returns the date the user joined this server;$memberJoinedDate or $memberJoinedDate[userID;date/time/ms (optional)]",
  $argsCheck: "Checks for user arguments.;$argsCheck[(>/</none)number;error message]",
  $setMessageVar: "Sets a message variable value;$setMessageVar[variable;value;messageID (optional)]",
  $suppressErrors: "Suppress all the errors and sends a custom one. {error} will contain the error that was thrown.;$suppressErrors or $suppressErrors[message]",
  $serverChannelExists: "$serverChannelExists;$serverChannelExists[channelID]",
  $filterMessage: "Removes letters or numbers from given text;$filterMessage[message;letterOrSymbols]",
  $onlyNSFW: "Makes this command only executable in nsfw channels.;$onlyNSFW[error message]",
  $playSong: "Plays a song from youtube. Support Playlist & URL;$playSong[song;leave vc time;defean (yes or no);error message]",
  $getRoleColor: "Gets the color of given role ID;$getRoleColor[roleID]",
  $getBotInvite: "Returns the bot's invite.",
  $onlyForServers: "the command will only be executable in these guild IDs.;$onlyForServers[guildID;guildID;...]",
  $log: "Logs something in the console / terminal.;$log[text]",
  $getEmbed: "Gets information on an embed.;$getEmbed[channelID;messageID;property]",
  $djsEval: "Evals a js + djs code.;$djsEval[code;output (yes/no) (optional)]",
  $messageAttachment: "Returns the first attachment url of this message. (if any)",
  $volume: "Returns Current Volume Number & Set a volume for the Songs;$volume or $volume[number]",
  $onlyBotPerms: "Checks for bot permissions in this guild;$onlyBotPerms[perm1;perm2;...;error message]",
  $sendDM: "Sends a dm message to given user ID.;$sendDM[userID;message]",
  $cloneChannel: "Clones this channel.",
  $setGuildName: "Sets a new Name for this guild.;$setGuildName[name]",
  $setGuildIcon: "Sets a new Icon for this guild.;$setGuildIcon[url]",
  $deleteIn: "Deletes the bot's response after given time;$deleteIn[time]",
  $userPerms: "Returns the user's key permissions.;$userPerms or $userPerms[userID;separator (optional)]",
  $rolePerms: "Returns the role key permissions.;$rolePerms[roleID;separator (optional)]",
  $songInfo: "Displays information about the song that is being played.;$songInfo[property]",
  $onlyForRoles: "The command will be only executed if the user has any of these role IDs / Names.;$onlyForRoles[roleID/Name;roleID/Name;...;error message]",
  $botTyping: "Shows that the bot is currently typing",
  $uptime: "Uptime of the Bot",
  $hasRole: "Checks if the user has the given role.;$hasRole[userID;roleID]",
  $channelUsed: "Returns the channel ID where this callback came from",
  $botLeave: "The bot is forced to leave the guild;$botLeave or $botLeave[guildID]",
  //UPDATE 0.6.0//
  $findServerChannel: "Returns a channel ID in this server, or the channel ID this command was ran in.;$findServerChannel[name/mention/id]",
  $messageSlice: `Slices this message from X to Y (or just X).;$messageSlice[from;to (optional)]`,
  $usersWithRole: "Returns a list of users with given role (members are given from the cache.);$usersWithRole[roleID;separator (optional);forceCaching (yes/no)(optional)]",
  $getCustomStatus: "Gets the user's custom status state or emoji. (if any);$getCustomStatus or $getCustomStatus[userID;state/emoji (optional)]",
  $resetUserVar: "Resets user variables values for this guild.;$resetUserVar[variable]",
  $resetGlobalUserVar: "Resets global user variable values.;$resetGlobaUserVar[variable]",
  $resetVar: "Resets global variable values.;$resetVar[variable]",
  $repeatMessage: "Repeats a message for X times.;$repeatMessage[times;message]",
  $randomUserID: "Returns a random user ID from this server.",
  $addObjectProperty: "Adds a key with a value to the existing object.;$addObjectProperty[key;value]",
  $createObject: "Creates an object that can be used later.;$createObject[object string]",
  $getObjectProperty: "Gets a property value from given key.;$getObjectProperty[key]",
  $randomChannelID: "Returns a random text channel ID.",
  $randomMention: "Mentions a random user of this server.",
  $roundTenth: "Rounds a number to given unit.;$roundTenth[number;round]",
  "$getMessage[": "Gets information of given message ID.;$getMessage[channelID;messageID;userID/content/description]",
  $colorRole: "Changes the color of given role ID.;$colorRole[roleID;hex or int color]",
  $isValidObject: "Checks if given string is a valid object.;$isValidObject[string {}]",
  $resetServerVar: "Resets server variables values.;$resetServerVar[variable]",
  $onlyIfMessageContains: "Checks if 'text' contains all the provided words.;$onlyIfMessageContains[text;word1;word2;...;error message]",
  $skipSong: "Skip the current song to next queue song;$skipSong",
  $pauseSong: "Pause the current song;$pauseSong",
  $resumeSong: "Resume the song from being paused;$resumeSong",
  $stopSong: "Stop the bot from playing songs;$stopSong",
  //UPDATE 0.6.5 - DBD.JS :3
  $removeSplitTextElement: "Removes an element or elements from $textSplit by using their indexes.;$removeSplitTextElement[index;index2;...]",
  $usersInChannel: "Returns the users that are connected to this voice channel.;$usersInChannel[channelID;id/mention/username (optional);separator (optional)]",
  $slowmode: "Sets a channel slowmode (or removes it by using 0).;$slowmode[channelID;time]",
  $randomGuildID: `Returns a random guild ID the bot's in.`,
  $setBotAvatar: "Sets the bot's avatar.;$setBotAvatar[url]",
  $usersBanned: "Returns a list of users that are banned from this guild.;$usersBanned or $usersBanned[id/mention/username;separator (optional)]",
  $setBotName: "Sets the bot's name.;$setBotName[new name]",
  $isBanned: `Checks if given user ID is banned from the server, returns true or false.;$isBanned[userID]`,
  $modifyChannelPerms: `Modifies the permissions of a channel for given user or role ID.;$modifyChannelPerms[channelID;+perm1;-perm2;/perm3;+perm4;...;roleID/userID]`,
  $loopQueue: "Loop the current songs in the queue. Returns whether or not it's looping`;$loopQueue",
  //UPDATE 0.7.0 - DBD.JS :3
  $deleteEmojis: "Delete an emoji or emojis from this server.;$deleteEmojis[emoji1;emoji2;...]",
  $serverEmojis: "Returns the emojis of this guild.",
  $emojiCount: "Returns the amount of emojis in this server",
  $randomRoleID: "Returns a random role ID from this guild.",
  $findRole: "Returns a role ID if the query matches an option.;$findRole[id/name/mention]",
  $cacheMembers: "Caches all the members of this guild. (may spike memory usage up)",
  $forEachGuildChannel: "Loop over every guild channel in this guild executing awaited commands.;$forEachGuildChannel[awaited command 1;awaited command 2;...]",
  $forEachChannel: "Loop over every channel this bot can see executing awaited commands.;$forEachChannel[awaited command 1;awaited command 2;...]",
  $forEachUser: "Loop over every (cached) user executing awaited commands.;$forEachUser[awaited command 1;awaited command 2;...]",
  $forEachMember: "Loop over every (cached) guild member in this guild executing awaited commands.;$forEachMember[awaited command 1;awaited command 2;...]",
  "$forEachGuild[": "Loop over every guild this bot's in executing awaited commands.;$forEachGuild[awaited command 1;awaited command 2;...]",
  $isMuted: "Checks if the user is self-muted.;$isMuted[userID]",
  $argsCount: "Returns the amount of user arguments.",
  $messageExists: "Checks if a message exists by using its ID;$messageExists[channelID;messageID]",
  $hasEmbeds: "Checks if given message ID contains an embed. returns true or false;$hasEmbeds[channelID;messageID]",
  "$clearReaction[": "Removes a reaction from given user ID.;$clearReaction[channelID;messageID;userID;emoji]",
  $clearReactions: "Clears all the user reactions assigned to one emoji or all the reactions of this message.;$clearReactions[channelID;messageID;all/emoji]",
  $getReactions: "Returns a list of users that reacted to this reaction.;$getReactions[channelID;messageID;emoji;mention/username/id]",
  $onlyForCategories: "The command will only be executable in channels under one of these category IDs.;$onlyForCategories[categoryID;categoryID2;...;error message]",
  $onlyForChannels: "The command will only be executable in the provided channel IDs.;$onlyForChannels[channelID;channelID2;...;error message]",
  $serverRegion: "Return the Guild region",
  $messageType: "Returns the type of this message.",
  $modulo: "Returns the remainder of a division.;$modulo[5;2]",
  $cpu: "Returns the cpu usage.",
  $maxRam: "Total memory for this process.",
  $modifyRole: "Modifies a role by using their ID.;$modifyRole[roleID;name;color;mentionable;hoisted]",
  $setStatus: "Sets the bot's status.;$setStatus[text;type;status]||$setStatus[$allMembersCount members!;watching;dnd]",
  $channelTopic: "Returns the channel topic.;$channelTopic or $channelTopic[channelID]",
  //UPDATE 1.1.0 - DBD.JS :3
  $serverBanner: "Returns the Server Banner.;$serverBanner or $serverBanner[guildID;size (optional);dynamic (yes/no)(optional)]",
  $serverBoostLevel: "Return the Level of Server Count:$serverBoostLevel",
  $playSpotify: "Play a Spotify playlist;$playSpotify[url;show success (number/name);error message]",
  "$skipTo[": "Skip to a certain number in the queue;$skipTo[number]",
  $newTicket: "Creates a ticket with given options;$newTicket[ticket name;ticket message;categoryID;return ticket ID;error message]",
  $closeTicket: "Closes a ticket with given options;$closeTicket[error message]",
  $isMentioned: "Checks if the role or channel or user was mentioned / everyone;$isMentioned[userID/roleID/channelID/everyone]",
  $createWebhook: "Creates a webhook for this channel, bot has to have manage webhooks permission;$createWebhook[channelID;name;avatar;returnWebhookID&Token (yes/no);separator]",
  $sendWebhook: "Sends a message through a webhook by using its ID and token;$sendWebhook[webhookID;webhookToken;message;options...]",
  $referenceChannelID: "The ID of the channel where this user replied in",
  $referenceMessageID: "The ID of the message that the user replied to",
  $referenceGuildID: "The ID of the guild where the user replied in",
  //UPDATE 1.2.0
  $setChannelTopic: "Sets the topic of a channel with given ID;$setChannelTopic[channelID;topic]",
  $deleteWebhook: "Deletes a webhook by using its token and ID;$deleteWebhook[webhookID;webhookToken]",
  $pinMessage: "Pins the user's message or other message using its channel id and message id;$pinMessage or $pinMessage[channelID;messageID]",
  $unpinMessage: "Unpins the user's message or other message by using its message and channel id;$unpinMessage or $unpinMessage[channelID;messageID]",
  $getInviteInfo: "Gets invite info from given invite code;$getInviteInfo[code/url;maxUses/uses/channelID/guildID/userID/isTemporary/expiresAt/createdAt/url]",
  $channelCategoryID: "Returns the ID of the category this channel belongs to;$channelCategoryID or $channelCategoryID[channelID]",
  $commandInfo: "Returns a property value of a command by using its name or one of its aliases;$commandInfo[command name;property]",
  $reboot: "Restarts the bot, requires the path to the main file.;$reboot[path]",
  $isUserDMEnabled: "Checks if the user has DMs open, returns true or false;$isUserDMEnabled or $isUserDMEnabled[userID]",
  $addMessageReactions: "Add reactions to a message by using its channel and message ID;$addMessageReactions[channelID;messageID;reaction1;reaction2;...]",
  $advancedTextSplit: `First field is the message we want to split and get indexes from\nsecond field would be the split used in the text and the next field would get the value of the index, setting this index value as the new text.\nNext fields work as splitter and new index.;$advancedTextSplit[text;split;index;split;index;...]||//in this example we will use a discord message link, we will get the message ID from this link.
  The message ID is $advancedTextSplit[https://discord.com/channels/773352845738115102/773357374328012840/793564340513931285;//;2;/;5]!
  `,
  $packageVersion: "Returns the dbdjs version you're currently using",
  $isMentionable: "Checks whether the role is mentionable or not;$isMentionable[roleID]",
  $isHoisted: "Checks if the role is hoisted above all the other roles;$isHoisted[roleID]",
  $getLeaderboardInfo: "beta;$getLeaderboardInfo[variable;id;user/globaluser/server;option]",
  $isManaged: "Checks if this role is managed by discord or not;$isManaged[roleID]",
  $isValidHex: "Checks if given hex code or int is valid;$isValidHex[int or hex]",
  $webhookExists: "Checks if a webhook exists by using its ID and token;$webhookExists[webhookID;webhookToken]",
  $modifyWebhook: "Modifies a webhook by using its token and ID;$modifyWebhook[webhookID;webhookToken;name;avatar (optional)]",
  $oldMessage: "The content of the message before it was updated (if any)",
  $inviteMaxUses: "max uses for the created / deleted invite",
  $fetchInvites: "fetches and loops over every invite executing awaited commands;$fetchInvites[awaited command1;awaited command2;...]",
  $isValidLink: "Checks if given link is valid or not (might not be accurate);$isValidLink[link or url]",
  $inviteUses: "uses this invite have",
  $inviteChannelID: "the channel ID this invite was created for",
  $inviteGuildID: "the ID of the guild this invite links to",
  $inviteUserID: "the invite creator ID",
  $inviteCode: "the code of the invite",
  $inviteURL: "the url for this invite",
  //$inviteTemporary: "whether if the invite is temporary or not", 
  $isDeafened: "Checks if the user is self-deafened.;$isDeafened[userID",
  $playSoundCloud: "Play SoundCloud Track URL;$playSoundCloud[url;soundcloud client id (optional);leave vc time;defean (yes or no);error message]",
  //1.3.0
  $getSlashCommandOptions: `Get the options of a slash command using its command name;$getSlashCommandOptions[name] or $getSlashCommandOptions[name;guildID]`,
  $getSlashCommandID: `Get the ID of a slash command by using its name;$getSlashCommandID[name] or $getSlashCommandID[name;guildID]`,
  $reply: `Replies to given message ID;$reply[messageID;message;mention (yes/no)]`,
  $modifySlashCommand: `Modify a slash command by using the ID of the guild it belongs to and the ID of the command;$modifySlashCommand[guildID;commandID;name;description;options (optional)]`,
  $deleteSlashCommand: `Deletes a slash command from given guild ID, by either using slash command name or ID;$deleteSlashCommand[guildID;name/id]`,
  $createSlashCommand: `Creates a slash command for given guild ID, said guild MUST have invited the bot with bot.applications scope authorized, everything after description field is optional;$createSlashCommand[guildID;name;description;options;options;...]||
//Create a slash command with one option, that is required
$createSlashCommand[$guildID;say;I'll repeat what u said;message:the message I have to repeat:true:3] Successfully created a slash command! 

/*
* this will create a slash command with name 'say', and one option which is the message to repeat
* options field goes as follow:
* nameOfTheOption:descriptionOfTheOption:isRequired(true/false):optionType(1-8)
* 3 stands for string 
*/
  `,
  $serverSplash: "Returns Server Invite Splash;$serverSplash or $serverSplash[guildID;size (optional)]",
  $sendCrosspostingMessage: "Sends a message to multiple channels;$sendCrosspostingMessage[message;channelID;channelID;...]",
  $reactionCount: `Returns the amount of people that have given this reaction to this message;$reactionCount[channelID;messageID;emoji]`,
  $botPing: "Returns the Bot Message ping",
  $interactionReply: "replies to an interaction (slash command);$interactionReply[message;embeds...]",
  $clearSongQueue: "Clear all songs in queue besides 1st song in queue",
  $messageID: `Returns the user's message ID `,
  //$activityTest: `test`
  //1.5.0  <3
  $serverNames: `Returns the name of every guild you bot is in`,
  $error: "Returns the error the interpreter threw;$error",
  $executionTime: `Returns the time the interpreter took to execute every function in the code (in milliseconds)\nThis function won't work in embeds`,
  $allEmojiCount: `Returns the total emoji count of all the guilds your bot is in`,
  $findMembers: "Finds multiple member from this guild through given query and optionally makes a list of members found or chooses one of the list, returning the ID;$findMembers[query;limit (optional);{position} - {username} - {id} (optional);getID (optional)]",
  $vanityUses: `The uses the vanity link of this server have`,
  $vanityURL: `The invite code of the vanity link`, 
  $createCollection: "Creates a collection with given name, you can store values here, these will be cleared upon bot restart.;$createCollection[name]", 
  $if: "determines whether given condition is true or false and executes a conditional code if the statement is false or true\nThere can be as many $elseIf as you need, remember these must go in between $if and $else (if $else was used).;$if[value(!=/==/</>/>=/<=)value2]\ncode\nelseIf[value1(==/!=/</>/>=/<=)value2] (optional)\ncode\n$endelseIf (required if using $elseIf)\n$else (optional)\ncode\n$endif (required)||$if[$message[1]==hello]\n$title[Hello $username!]\n$color[GREEN]\n$else\n$title[Please say hello!]\n$color[RED]\n$endif",
  $pruneMusic: "Deletes the old Message of Music Start and send the new one to avoid flooding", 
  $shuffleQueue: "Shuffle the Queue",
  $replaceTextWithRegex: "Uses a regular expression to replace matching queries;$replaceTextWithRegex[text;regex;flags;new text]", 
  $oldUser: "This function holds data of the old user, used in update user callback, or else any data will be empty.;$oldUser[userOption]", 
  $oldPresence: "The function that holds old data of the user's presence, used in update presence callback, or else any data will be empty;$oldPresence[presenceOption]",
  $getObject:"Returns a JSON of created/modified $createObject", 
  $findNumbers: "Takes every number from given string and returns them alone;$findNumbers[string]", 
  $updateCommands: "Updates all the commands of your command handler\nThis function won't be usable if you haven't used our built-in command handler with Bot.loadCommands(path)", 
  $findSpecialChars: "Takes all the non number/letter from given string and returns the alone;$findSpecialChars[string]", 
  $findChars: "Takes all the letters from given string and returns them alone;$findChars[string]", 
  $oldRole: "Function that holds data of the role before it was updated, used in role update callback, or else any data will be empty;$oldRole[roleOption]", 
  $newRole: "Function that holds data of a role that was created, updated, or deleted. Used in role update / delete / create callbacks, or else it won't give any data;$newRole[roleOption]", 
  $oldChannel: "Function that holds data of the channel before it was updated, used in channel update callback, or else any data will be empty;$oldChannel[channelOption]", 
  $newChannel: "Function that holds data of the updated channel, used in channel update, delete and create callbacks, or else any data will be empty ;$newChannel[channelOption]", 
  $year: "Returns current year", 
  $day: "Returns current day", 
  $month: "Returns current month", 
  $second: "Returns current second",
  $hour: "Returns current hour", 
  $minute: "Returns current minute", 
  $botOwnerID: "Returns the ID of the bot owner\nIf the bot belongs to a team, it'll return multiple IDs\nOptionally, and if there is more than one owner (team), you can input a separator.;$botOwnerID or $botOwnerID[separator]", 
  $allChannelsCount: "Returns the amount of all the channels of all the guilds your bot is in\nYou can optionally pass types of channels to count;$allChannelsCount or $allChannelsCount[type;type;...]", 
  $stringStartsWith: "Determines whether given message starts by another message or not;$stringStartsWith[message;text]", 
  $deleteMessage: "Deletes a message using its ID, if no channel ID is present it'll use the default channel;$deleteMessage[messageID] or $deleteMessage[channelID;messageID]", 
  //1.9.4 
  $messageWebhookID: "Returns the ID of the webhook that sent this message", 
  $messageFlags: "Returns the message flags for this message"
};
module.exports = Parser;