const ytdl = require("ytdl-core")
const search = require("yt-search")
const embed = require("../../handlers/errors.js")
const execute = require("../../handlers/MusicPlayer.js")
const msp = require("ms-parser")
const pms = require("parse-ms")
const urlPattern = /(watch\?v=(.+)|youtu.be\/(.+))/
const playlistPattern = /playlist\?list=(.+)/
let timeout

module.exports = async d => {
    const code = d.command.code
    
    const inside = code.split("$playSong[")[1].split("]")[0]

    let [
        url,
        time = "1s",
        deafen = false,
        error = ":x: Error while making the request."
    ] = inside.split(";")
    try{
        time = msp(time).ms
      } catch {
        time = msp("1s").ms
      }
      deafen = (deafen === "yes")
    url = url.addBrackets()

    let videos = {
        videos:[]
    }

    const matchedList = url.match(playlistPattern)
    const listId = matchedList instanceof Object ? matchedList[1] : undefined

    const matchedURL = url.match(urlPattern)
    const urlID = matchedURL instanceof Object ? (matchedURL[2] || matchedURL[3]) : undefined

    try {
        if (typeof listId != 'string') throw new Error('err')

        

        const playlist = await search({listId: listId})


        const items = []
        for (const video of playlist.videos) items.push(video)

        const songInfo = items.shift()
        videos.videos[0] = {
            title: songInfo.title.removeBrackets(),
            description: songInfo.description,
            duration: songInfo.duration,
            thumbnail: songInfo.thumbnail,
            author:{
                name:songInfo.author.name,
                url:songInfo.author.url
            },
            url: "https://www.youtube.com/watch?v="+songInfo.videoId,
            stream: "ytdl",
            prune:false
        }
        if (items.length) videos.funcs = async server => {
            for (const video of items) {
               	const songInfo = video

                server.songs.push({
                    title: () => songInfo.title.removeBrackets(),
            description: () => songInfo.description,
            duration: () => songInfo.duration.split("seconds").join("Seconds"),
            duration_left: (server) => {
          if(!server) return;
          const ms = msp(songInfo.duration.toString().split(" ")[0] + "s").ms
          const time = Math.floor(ms - new Date(server.connection.dispatcher.streamTime - server.connection.dispatcher.pausedTime))
          const ISO = new Date(time).toISOString().substr(11, 11).split(":")
          
          if (ISO[0] === "00") {
            ISO.shift()
           ISO[1] = Math.floor(parseInt(ISO[1]))

           if (ISO[1].toString().length === 1) ISO[1] = "0" + ISO[1].toString()

          } else {
           ISO[2] = Math.floor(parseInt(ISO[2]))

           if (ISO[2].toString().length === 1) ISO[2] = "0" + ISO[2].toString()
          }
          
          return `${Math.floor(time / 1000)} Seconds (${ISO.join(":")})`
        },
            thumbnail: () => songInfo.thumbnail,
            publisher:() => video.author.name,
        publisher_url:() => video.author.url,
        userID: () => d.message.author.id,
            url: () => "https://www.youtube.com/watch?v="+songInfo.videoId,
            stream: "ytdl",
            prune:false
                })

                if(server.state === "ENDED") {
                    await execute(d, true, error)
                }
            }
  }
    } catch {
        try {
            if (typeof urlID != 'string') throw new Error('err')
    
            videos = {
                videos: []
            }
    
            const songInfo = await search({videoId:urlID})
            
            videos.videos[0] = {
                title: songInfo.title.removeBrackets(),
            description: songInfo.description,
            duration: songInfo.duration,
            thumbnail: songInfo.thumbnail,
            author:{
                name:songInfo.author.name,
                url:songInfo.author.url
            },
            url: songInfo.url,
            stream: "ytdl",
            prune:false
            }
        } catch {
            try {
                videos = await search(url)
            } catch (err) {
                console.log(err)
              
                return embed(d, error)
            }
        }
    }

    const video = videos.videos[0]

    const info = {
        title: () => video.title.removeBrackets(),
        description: () => video.description,
        duration: () => video.duration.toString().split("seconds").join("Seconds"),
        thumbnail: () => video.thumbnail,
        duration_left: (server) => {
          if(!server) return;
          const ms = msp(info.duration().split(" ")[0] + "s").ms
          const time = Math.floor(ms - new Date(server.connection.dispatcher.streamTime - server.connection.dispatcher.pausedTime))
          const ISO = new Date(time).toISOString().substr(11, 11).split(":")

          if (ISO[0] === "00") {
            ISO.shift()
           ISO[1] = Math.floor(parseInt(ISO[1]))

           if (ISO[1].toString().length === 1) ISO[1] = "0" + ISO[1].toString()

          } else {
           ISO[2] = Math.floor(parseInt(ISO[2]))

           if (ISO[2].toString().length === 1) ISO[2] = "0" + ISO[2].toString()
          }

          
          
          return `${Math.floor(time / 1000)} Seconds (${ISO.join(":")})`
        },
        publisher: () => video.author.name,
        publisher_url: () => video.author.url,
        userID: () => d.message.author.id,
        url: () => video.url,
        stream: "ytdl",
	    prune:false
    }

    let server = d.client.servers.get(d.message.guild.id)

    if (!server) {
        const vc = await d.message.member.voice.channel

        if (!vc) return embed(d, error)
        let connection
        try{
                 connection = await vc.join()
        } catch(err) {
            console.error("I was unable to Join, Reason: \n" +err)
            return embed(d, "I was unable to join, Error: "+err.message)
        }

        const constructor = {
            voice: d.message.member.voice.channel,
            connection: connection,
            songs: [],
            loopSong: false,
            loopQueue: false,
            volume: null,
            text: d.message.channel,
            playing: true,
            state:"ENDED",
            vc_legacy:time,
        deafen:deafen,
		pruneEnabled:false
        }

        constructor.songs.push(info)
        constructor.volume = 100

        d.client.servers.set(d.message.guild.id, constructor)

        server = constructor



        try {
            await execute(d, true, error)
        } catch (err) {
            console.log(err)

            return embed(d, error)
        }
    } else {
        server.songs.push(info)
        d.client.servers.set(d.message.guild.id, server)
        if(server.state === "ENDED") {
            await execute(d, true, error)
            
        }
    }

    if (typeof videos.funcs == 'function') videos.funcs(server)

    return {
        code: code.replaceLast(`$playSong[${inside}]`, video.title)
    }
}