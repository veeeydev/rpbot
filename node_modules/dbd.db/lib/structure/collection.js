const fs = require('fs')
const Util = require('../util')
const DBDError = require('./dbdError')
const Writer = require('./writer')
const DB = require('./db')
const { EventEmitter } = require('events')

/**
 * The hub to interact with the db Collections
 * @extends {EventEmitter}
 */
class Collection extends EventEmitter {
	/**
	 * @param {!DB} db The database
	 * @param {!String} name The collection name
	 * @param {!Number} [ttl] Make the collection support ttl or not
	 */
	constructor(db, opts) {
		super()

		this.ready = false
		this.closed = false
		this.db = db
		this.name = `${opts.name}.chson`
		this.ttl = opts.ttl || 0
		this.ttlCheck = null
		this.ttlChecking = false
		this.indexes = {}
		this.ttls = {}

		this.writer = new Writer(db, this)

		this.once('ready', () => {
			this.ready = true

			if (this.ttl >= 15) {
				this.checkTTL = async () => {
					const entries = Object.entries(this.ttls)
					const expired = []

					let i = 0

					while (i < entries.length) {
						if (parseInt(entries[i][1]) <= Date.now()) expired.push(entries[i][0])

						i++
					}

					if (!expired.length) return

					const indexes = expired.map(key => this.indexes[key])

					const indexs = Object.entries(this.indexes)
					const newIndexes = {}
					const re = []

					let id = 0

					while (id < indexs.length) {
						const index = expired.indexOf(indexs[id][0])

						if (index >= 0) {
							delete this.ttls[indexs[id][0]]

							let idx

							const reid = re.findIndex(ind => ind <= indexs[id][1])

							if (reid < 0) idx = indexs[id][1]
							else idx = indexs[id][1] - (re.length - reid)

							re.push(idx)

							this.emit('expired', this.db.cache.get(this.displayName)[idx])

							this.db.cache.get(this.displayName).splice(idx, 1)

							re.sort((a, b) => b - a)

							id++

							continue
						}

						const reid = re.findIndex(ind => ind <= indexs[id][1])

						if (reid < 0) {
							newIndexes[indexs[id][0]] = indexs[id][1]

							continue
						}

						newIndexes[indexs[id][0]] = indexs[id][1] - (re.length - reid)

						id++
					}

					this.indexes = newIndexes

					this.writer.emit('exec')

					return
				}

				this.ttlCheck = setInterval(async () => {
					if (this.ttlChecking) await new Promise(async (resolve, reject) => {
						function checkTTL(check) {
							if (!check) {
								this.off('ttl', checkTTL)
								resolve()
							}
						}

						this.on('ttl', checkTTL)

						if (!this.ttlChecking) resolve()
					})

					this.emit('ttl', true)

					await this.checkTTL()

					this.emit('ttl', false)
				}, this.ttl * 1000)
			}
		})

		new Promise(async (resolve, reject) => {
			try {
				if ((await fs.promises.stat(`${this.db.name}/${this.name}`)).isFile()) {
					const stream = fs.createReadStream(`${this.db.name}/${this.name}`)

					let data = ''

					stream.on('data', chunk => {
						data += chunk
					})

					stream.on('end', async () => {
						data = data.trim().replace(/\n/g, '').split(' ')

						const dataArr = []

						let iD = 0
						let newData = ''

						while (iD < data.length) {
							dataArr.push(data[iD])

							if (dataArr.length > 100) {
								newData += String.fromCharCode(...dataArr)

								dataArr.length = 0
							}

							iD++
						}

						if (dataArr.length) {
							newData += String.fromCharCode(...dataArr)

							dataArr.length = 0
						}

						const json = await new Promise(async resolveJSON => {
							try {
								resolveJSON(JSON.parse(`[${newData.length < 2 ? '' : `${newData}`}]`))
							} catch {
								reject(new DBDError(`Error while parsing json: ${this.name}`, 3))
							}
						})

						this.db.cache.set(opts.name, json)

						async function indexer() {
							let i = 0

							while (i < db.cache.get(opts.name).length) {
								if (db.collections.get(opts.name).indexes[db.cache.get(opts.name)[i]._index]) {
									i++

									continue
								}

								db.collections.get(opts.name).indexes[db.cache.get(opts.name)[i]._index] = i++
							}

							return
						}

						async function parseTTL() {
							let i = 0

							while (i < db.cache.get(opts.name).length) {
								if (db.collections.get(opts.name).ttls[db.cache.get(opts.name)[i]._index]) {
									i++

									continue
								}

								if (typeof db.cache.get(opts.name)[i]._ttl === 'number') db.collections.get(opts.name).ttls[db.cache.get(opts.name)[i]._index] = db.cache.get(opts.name)[i]._ttl

								i++
							}

							return
						}

						try {
							if ((await fs.promises.stat(`${this.db.name}/${opts.name}.chmeta`)).isFile()) {
								const idStream = fs.createReadStream(`${this.db.name}/${opts.name}.chmeta`)

								let idData = ''

								idStream.on('data', chunk => {
									idData += chunk
								})

								idStream.on('end', async () => {
									idData = idData.trim().replace(/\n/g, '').split(' ')

									const idDataArr = []

									let iDa = 0
									let newIdData = ''

									while (iDa < idData.length) {
										idDataArr.push(idData[iDa])

										if (idDataArr.length > 100) {
											newIdData += String.fromCharCode(...idDataArr)

											idDataArr.length = 0
										}

										iDa++
									}

									if (idDataArr.length) {
										newIdData += String.fromCharCode(...idDataArr)

										idDataArr.length = 0
									}

									const idJson = await new Promise(async resolveJSON => {
										try {
											resolveJSON(JSON.parse(`{${newIdData.length < 2 ? '' : `${newIdData}`}}`))
										} catch {
											reject(new DBDError(`Error while parsing json: ${this.name}.chmeta`, 3))
										}
									})

									Object.assign(this.indexes, idJson)

									if (Object.keys(idJson).length !== Object.keys(this.indexes).length)
										await indexer()

									if (this.ttl >= 15) {
										await new Promise(async resolveTTL => {
											try {
												if ((await fs.promises.stat(`${this.db.name}/${opts.name}.chttl`))) {
													const ttlStream = fs.createReadStream(`${this.db.name}/${opts.name}.chttl`)

													let ttlData = ''

													ttlStream.on('data', chunk => {
														ttlData += chunk
													})

													ttlStream.on('end', async () => {
														ttlData = ttlData.trim().replace(/\n/g, '').split(' ')

														const ttlDataArr = []

														let iTTL = 0
														let newTTLData = ''

														while (iTTL < ttlData.length) {
															ttlDataArr.push(ttlData[iTTL])

															if (ttlDataArr.length > 100) {
																newTTLData += String.fromCharCode(...ttlDataArr)

																ttlDataArr.length = 0
															}

															iTTL++
														}

														if (ttlDataArr.length) {
															newTTLData += String.fromCharCode(...ttlDataArr)

															ttlDataArr.length = 0
														}

														const ttlJSON = await new Promise(async resolveJSON => {
														
															try {
															resolveJSON(JSON.parse(`{${newTTLData.length < 2 ? '' : `${newTTLData}`}}`))
								
															} catch (err) {
																reject(new DBDError(`Error while parsing json: ${this.name}.chttl`, 3))
															}
														})

														Object.assign(this.ttls, ttlJSON)

														resolveTTL()
													})
												} else throw new Error('Not a file!')
											} catch {
												await parseTTL()

												resolveTTL()
											}
										})
									}

									this.emit('ready')

									resolve()
								})
							} else throw new Error('Not a file!')
						} catch {
							await indexer()

							if (this.ttl >= 15) {
								await new Promise(async resolveTTL => {
									try {
										if ((await fs.promises.stat(`${this.db.name}/${opts.name}.chttl`))) {
											const ttlStream = fs.createReadStream(`${this.db.name}/${opts.name}.chttl`)

											let ttlData = ''

											ttlStream.on('data', chunk => {
												ttlData += chunk
											})

											ttlStream.on('end', async () => {
												ttlData = ttlData.trim().replace(/\n/g, '').split(' ')

												const ttlDataArr = []

												let iTTL = 0
												let newTTLData = ''

												while (iTTL < ttlData.length) {
													ttlDataArr.push(ttlData[iTTL])

													if (ttlDataArr.length > 100) {
														newTTLData += String.fromCharCode(...ttlDataArr)

														ttlDataArr.length = 0
													}

													iTTL++
												}

												if (ttlDataArr.length) {
													newTTLData += String.fromCharCode(...ttlDataArr)

													ttlDataArr.length = 0
												}

												const ttlJSON = await new Promise(async resolveJSON => {
													try {
														resolveJSON(JSON.parse(`{${newTTLData.length < 2 ? '' : `${newTTLData}`}}`))
													} catch {
														reject(new DBDError(`Error while parsing json: ${opts.name}.chttl`, 3))
													}
												})

												Object.assign(this.ttls, ttlJSON)

												resolveTTL()
											})
										} else throw new Error('Not a file!')
									} catch {
										await parseTTL()

										resolveTTL()
									}
								})
							}

							this.emit('ready')

							resolve()
						}
					})
				} else throw new Error('Not a file!')
			} catch {
				this.db.cache.set(opts.name, [])
				this.emit('ready')

				resolve()
				return
			}
		})
	}

	/**
	 * The collection name
	 * @returns {String}
	 */
	get displayName() {
		return this.name.substr(0, this.name.length - 6)
	}

	/**
	 * The collection size
	 * @returns {Number}
	 */
	get size() {
		return this.db.cache.get(this.displayName).length
	}
	
	/**
	 * The condition if the Collection can be used
	 * @returns {Boolean}
	 */
	
	get isOpen() {
	  return (this.ready && !this.closed)
	}

  /**
   * Destroy and delete the Collection
   * @returns {Promise<Boolean>}
   */
	async destroy() {
		if (!this.ready) await new Promise(async resolve => {
			this.once('ready', resolve)

			if (this.ready) resolve()
		})

		if (this.closed) throw new DBDError('Connection to collection already closed!', 10)

		this.closed = true

		super.removeAllListeners()

		if (this.ttlCheck) clearInterval(this.ttlCheck)

		if (this.ttlChecking) await new Promise(async resolve => {
			function checkTTL(check) {
				if (!check) {
					this.off('ttl', checkTTL)
					resolve()
				}
			}

			this.on('ttl', checkTTL)

			if (!this.ttlChecking) resolve()
		})

		if (this.writer.run) await new Promise(async resolve => {
			this.writer.once('ready', resolve)

			if (!this.writer.run) resolve()
		})

		await fs.promises.unlink(`${this.db.name}/${this.name}`).catch(err => { })

		await fs.promises.unlink(`${this.db.name}/${this.displayName}.meta`).catch(err => { })

		if (this.ttl >= 15) {
			await fs.promises.unlink(`${this.db.name}/${this.displayName}.ttl`).catch(err => { })
		}

		this.db.cache.delete(this.displayName)

		this.db.collections.delete(this.displayName)
	}

  /**
   * Close the Connection between the Collection, the data will be saved and remain in the Collection
	 * @returns {Promise<Boolean>}
   */
	async close() {
		if (!this.ready) await new Promise(async resolve => {
			this.once('ready', resolve)

			if (this.ready) resolve()
		})

		if (this.closed) throw new DBDError('Connection to collection already closed!', 10)

		this.closed = true

		super.removeAllListeners()

		if (this.ttlCheck) clearInterval(this.ttlCheck)

		if (this.ttlChecking) await new Promise(async resolve => {
			function checkTTL(check) {
				if (!check) {
					this.off('ttl', checkTTL)
					resolve()
				}
			}

			this.on('ttl', checkTTL)

			if (!this.ttlChecking) resolve()
		})

		if (this.writer.run) await new Promise(async resolve => {
			this.writer.once('ready', resolve)

			if (!this.writer.run) resolve()
		})

		this.db.cache.delete(this.displayName)

		this.db.collections.delete(this.displayName)

		delete this

		return true
	}

  /**
   * Finds data in the Collection
   * @param {!Object} filter The Filter to find the data
	 * @param {!Number} [max] Limit for the filter
   * @return {Promise<Array>}
   */
	async find(filter, max = Infinity) {
		if (!(filter instanceof Object)) throw new DBDError(`Data must be instanceof Object`, 9)

		if (this.closed) throw new DBDError('Connection to collection is closed!', 10)

		await this._check(filter)

		if (!this.ready) await new Promise(async resolve => {
			this.once('ready', resolve)

			if (this.ready) resolve()
		})

		if (this.closed) throw new DBDError('Connection to collection is closed!', 10)

		if (filter._index !== undefined) {
			const index = this.indexes[String(filter._index)]

			return [this.db.cache.get(this.displayName)[index]]
		}

		const find = await Util.find(this.db.cache.get(this.displayName), filter, max)

		return find
	}

  /**
   * Find one data in the Collection
   * @param {!Object} filter The Filter to find the data
   * @returns {Promise}
   */
	async findOne(filter) {
		if (!(filter instanceof Object)) throw new DBDError(`Data must be instanceof Object`, 9)

		if (this.closed) throw new DBDError('Connection to collection is closed!', 10)

		await this._check(filter)

		if (!this.ready) await new Promise(async resolve => {
			this.once('ready', resolve)

			if (this.ready) resolve()
		})

		if (this.closed) throw new DBDError('Connection to collection is closed!', 10)

		if (filter._index !== undefined) {
			const index = this.indexes[String(filter._index)]

			return this.db.cache.get(this.displayName)[index]
		}

		const findOne = await Util.findOne(this.db.cache.get(this.displayName), filter)

		return findOne.item
	}

	/**
	 * Method to set a data into collection
	 * @param {!Object} data The data to set
	 * @param {!Object} [filter] A filter to replace a data
	 * @returns {Promise<Boolean>}
	 */
	async set(data, filter) {
		if (!(data instanceof Object)) throw new DBDError('Data must be instanceof Object!', 9)

		if (this.closed) throw new DBDError('Connection to collection is closed!', 10)

		await this._check(data)

		if (!this.ready) await new Promise(async resolve => {
			this.once('ready', resolve)

			if (this.ready) resolve()
		})

		if (this.closed) throw new DBDError('Connection to collection is closed!', 10)

		if (!(filter instanceof Object)) {
			if (data._index === undefined) {
				let i = this.db.cache.get(this.displayName).length

				while (this.indexes[i]) i++

				data._index = String(i)
			}

			data._index = String(data._index)

			if (typeof this.indexes[data._index] === 'number') throw new DBDError('Duplicated data found!', 11)

			if (typeof data._ttl === 'number' && this.ttl >= 15) {
				this.ttls[data._index] = String(data._ttl)
			}

			this.db.cache.get(this.displayName).push(data)

			this.indexes[data._index] = this.db.cache.get(this.displayName).length - 1

			this.writer.emit('exec')

			return true
		}

		await this._check(filter)

		if (filter._index !== undefined) {
			const index = this.indexes[String(filter._index)]

			if (data._index === undefined) {
				data._index = String(filter._index)
			}

			data._index = String(data._index)

			if (data._index !== String(filter._index) && typeof this.indexes[data._index] === 'number') throw new DBDError('Duplicated data found!', 11)

			if (typeof data._ttl === 'number' && this.ttl >= 15) {
				this.ttls[data._index] = String(data._ttl)
			}

			if (data._index !== filter._index) delete this.indexes[filter._index]

			if (typeof index === 'number') {
				this.db.cache.get(this.displayName).splice(index, 1, data)

				this.indexes[data._index] = index
			} else {
				this.db.cache.get(this.displayName).push(data)

				this.indexes[data._index] = this.db.cache.get(this.displayName).length - 1
			}

			this.writer.emit('exec')

			return true
		}

		const obj = await Util.findOne(this.db.cache.get(this.displayName), filter)

		if (data._index === undefined) {
			if (obj.item) {
				data._index = obj.item._index
			} else {
				let i = this.db.cache.get(this.displayName).length

				while (this.indexes[i]) i++

				data._index = String(i)
			}
		}

		data._index = String(data._index)

		if (!obj.item && typeof this.indexes[data._index] === 'number') throw new DBDError('Duplicated data found!', 11)

		if (typeof data._ttl === 'number' && this.ttl >= 15) {
			this.ttls[data._index] = String(data._ttl)
		}

		if (obj.item && obj.item._index !== data._index) delete this.indexes[obj.item._index]

		if (typeof obj.index === 'number') {
			this.db.cache.get(this.displayName).splice(obj.index, 1, data)

			this.indexes[data._index] = obj.index
		} else {
			this.db.cache.get(this.displayName).push(data)

			this.indexes[data._index] = this.db.cache.get(this.displayName).length - 1
		}

		this.writer.emit('exec')

		return true
	}

	/**
	 * Method to delete a data from the collection
	 * @param {!Object} filter The filter of the data that will be deleted
	 * @param {!Number} [max] The maximum data to delete
	 * @returns {Promise<Boolean>}
	 */
	async delete(filter, max = Infinity) {
		const result = await this.find(filter, max)

		if (!result.length) return false

		const indexes = []
		const ids = []

		let id = 0

		while (id < result.length) {
			ids.push(result[id]._index)
			indexes.push(this.indexes[result[id]._index])

			id++
		}

		const indexs = Object.entries(this.indexes)
		const newIndexes = {}
		const re = []

		let i = 0

		while (i < indexs.length) {
			const index = ids.indexOf(indexs[i][0])

			if (index >= 0) {
				let idx

				const reid = re.findIndex(ind => ind <= indexs[i][1])

				if (reid < 0) idx = indexs[i][1]
				else idx = indexs[i][1] - (re.length - reid)

				re.push(idx)

				if (this.ttls[indexs[i][0]]) delete this.ttls[indexs[1][0]]

				this.db.cache.get(this.displayName).splice(idx, 1)

				re.sort((a, b) => b - a)

				i++

				continue
			}

			const reid = re.findIndex(ind => ind <= indexs[i][1])

			if (reid < 0) {
				newIndexes[indexs[i][0]] = indexs[i][1]

				i++

				continue
			}

			if (this.ttls[indexs[i][0]]) this.ttls[indexs[i][0]] = indexs[i][1] - (re.length - reid)

			newIndexes[indexs[i][0]] = indexs[i][1] - (re.length - reid)

			i++
		}

		this.indexes = newIndexes

		this.writer.emit('exec')

		return true
	}

	/**
	 * Check the data if it contains function
	 * @param {!object} data The data to check
	 */
	async _check(data) {
		const keys = Object.keys(data)

		let i = 0

		while (i < keys.length) {
			if (data[keys[i]] instanceof Object) {
				await this._check(data[keys[i]])
			}

			if (typeof data[keys[i]] === 'function') {
				throw new DBDError('Function is not allowed!', 7)
			}

			i++
		}
	}
}

module.exports = Collection