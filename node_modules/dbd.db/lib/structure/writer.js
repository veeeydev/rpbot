const fs = require("fs")
const DBDError = require('./dbdError')
const { EventEmitter } = require("events")
const { Readable } = require('stream')

class Writer extends EventEmitter {
	constructor(db, collection) {
		super()

		this.run = false
		this.queue = false
		this.db = db
		this.collection = collection

		super.on('exec', async () => {
			if (this.queue) return

			if (this.run) {
				if (this.queue) return

				this.queue = true

				await new Promise(async (resolve, reject) => {
					if (this.collection.closed) reject(new DBDError('Connection to collection is closed!', 10))

					this.once('ready', () => {
						if (this.collection.closed) reject(new DBDError('Connection to collection is closed!', 10))

						resolve()
						this.queue = false
					})

					if (!this.run) resolve()
				})
			}

			this.run = true

			const parallel = new EventEmitter()

			parallel.on('finish', check => {
				if (check === 3) {
					this.emit('ready')

					this.run = false

					parallel.removeAllListeners('finish')
				}
			})

			let parallels = 1

			const data = {
				cache: this.db.cache.get(collection.displayName),
				indexes: this.collection.indexes,
				ttl: this.collection.ttls
			}
			
			const readable = new Readable({
				read: () => {}
			})

			const writable = fs.createWriteStream(`${this.db.name}/${this.collection.name}`)

			const metaRead = new Readable({
				read: () => { }
			})

			const metaWrite = fs.createWriteStream(`${this.db.name}/${this.collection.displayName}.chmeta`)

			metaWrite.once('finish', () => {
				parallel.emit('finish', parallels++)
			})

			metaRead.pipe(metaWrite)

			this.stringify(Object.entries(data.indexes), metaRead)

			if (this.collection.ttl >= 15) {
				const ttlRead = new Readable({
					read: () => { }
				})

				const ttlWrite = fs.createWriteStream(`${this.db.name}/${this.collection.displayName}.chttl`)

				ttlWrite.once('finish', () => {
					parallel.emit('finish', parallels++)
				})

				ttlRead.pipe(ttlWrite)

				this.stringify(Object.entries(data.ttl), ttlRead)
			} else {
				parallel.emit('finish', parallels++)
			}

			writable.once('finish', () => {
				parallel.emit('finish', parallels++)
			})

			readable.pipe(writable)

			this.stringify(data.cache, readable, true)
		})
	}

	/** 
	 	* @param {!Array} data The data
	 	* @param {!Readable} readable The readable stream
	 	* @param {!Boolean} isData Wether or not the data is collection data
		* @returns {String}
		*/
	async stringify(data, readable, isData = false) {
		if (!(data instanceof Object)) throw new DBDError('Data must be an object!', 6)

	  let i = 0
	  
	  while (i < data.length) {
	  	if (!isData) {
	  		const string = `"${data[i][0]}":${data[i][1]}`
	  		
	  		readable.push(string.split('').map(str => str.charCodeAt(0)).join(' '))
	  	} else {
	  		const string = await new Promise(async resolve => {
	  			resolve(JSON.stringify(data[i]))
	  		})
	  		
	  		readable.push(string.split('').map(str => str.charCodeAt(0)).join(' '))
	  	}

			const random = Math.random() < 0.5
	  	
	  	if (i < data.length-1) readable.push(` 44 `)

			if (i < data.length-1 && random) readable.push('\n')
	  	
	  	i++
	  }
	  
	  readable.push(null)
	}
}

module.exports = Writer